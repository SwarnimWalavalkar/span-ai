import { Box, Editor, FileHelpers, getSvgAsImage, TLShapePartial } from 'tldraw'
import { TLAiChange, TLAiContent, TLAiPrompt } from '../../shared/types'
import { exhaustiveSwitchError } from '../../shared/utils'
import { TldrawAiTransformConstructor } from './TldrawAiTransform'

export interface TldrawAiManagerOptions {
	transforms?: TldrawAiTransformConstructor[]
}

/**
 * The AI manager for tldraw. This class is used to produce prompts for the AI
 * using data from the editor, and to update the editor based on the
 * changes generated by the AI.
 */
export class TldrawAiManager {
	constructor(
		public readonly editor: Editor,
		public readonly options = {} as TldrawAiManagerOptions
	) {}

	dispose() {}

	/**
	 * Creates and prepare a prompt, returning the prompt
	 * and a function to handle changes.
	 *
	 * @param message The user's message
	 */
	async generate(message: TLAiPrompt['message']) {
		const { transforms: _transformCtors = [] } = this.options
		const transforms = _transformCtors.map((ctor) => new ctor(this.editor))

		let prompt = await this.getPrompt(message)

		for (const transform of transforms) {
			if (transform.transformPrompt) {
				prompt = transform.transformPrompt(prompt)
			}
		}

		transforms.reverse()

		const handleChange = (change: TLAiChange) => {
			for (const transform of transforms) {
				if (transform.transformChange) {
					change = transform.transformChange(change)
				}
			}
			this.applyChange(change)
		}

		const handleChanges = (changes: TLAiChange[]) => {
			for (const transform of transforms) {
				if (transform.transformChanges) {
					changes = transform.transformChanges(changes)
				}
			}
		}

		return {
			prompt,
			handleChange,
			handleChanges,
		}
	}

	/**
	 * Apply a change to the editor.
	 *
	 * @param change The change to apply
	 */
	applyChange(change: TLAiChange) {
		const { editor } = this

		if (editor.isDisposed) return

		try {
			switch (change.type) {
				case 'createShape': {
					editor.createShape(change.shape)
					break
				}
				case 'updateShape': {
					editor.updateShape(change.shape as TLShapePartial)
					break
				}
				case 'deleteShape': {
					editor.deleteShape(change.shapeId)
					break
				}
				case 'createBinding': {
					editor.createBinding(change.binding)
					break
				}
				case 'updateBinding': {
					editor.updateBinding(change.binding)
					break
				}
				case 'deleteBinding': {
					editor.deleteBinding(change.bindingId)
					break
				}
				default:
					exhaustiveSwitchError(change)
			}
		} catch (e) {
			console.error('Error handling change:', e)
		}
	}

	/**
	 * Create the prompt to be sent to the AI.
	 *
	 * @param prompt The user's prompt
	 * @param options Options to generate the input
	 */
	async getPrompt(
		prompt: TLAiPrompt['message'],
		options = {} as Partial<Pick<TLAiPrompt, 'canvasContent' | 'contextBounds' | 'promptBounds'>>
	): Promise<TLAiPrompt> {
		const { editor } = this
		const {
			contextBounds = editor.getViewportPageBounds(),
			promptBounds = editor.getViewportPageBounds(),
		} = options

		const content = options.canvasContent ?? this.getContent(promptBounds)

		// Get image from the content
		const image = await this.getImage(content)

		return {
			message: prompt,
			canvasContent: content,
			contextBounds: roundBox(contextBounds),
			promptBounds: roundBox(promptBounds),
			image,
		}
	}

	/**
	 * Get the content from the current page.
	 *
	 * @param bounds The bounds to get the content for
	 */
	private getContent(bounds: Box): TLAiContent {
		const { editor } = this

		// Get the page content (same as what we put on the clipboard when a user copies) for the shapes
		// that are included (contained or colliding with) the provided bounds

		let content: TLAiContent | undefined = {
			bindings: [],
			shapes: [],
			assets: [],
			...editor.getContentFromCurrentPage(
				editor
					.getCurrentPageShapesSorted()
					.filter((s) => bounds.includes(editor.getShapeMaskedPageBounds(s)!))
			),
		}

		// If we don't have content, it's either an empty page or an empty section of the page.
		// This is an acceptable case; but let's send along an empty content instead of undefined.
		if (content) {
			// the content is a TLContent, but we want to omit the schema for TLAiContent
			content.shapes = structuredClone(content.shapes)
			content.bindings = structuredClone(content.bindings)
			delete (content as any).schema
			delete (content as any).rootShapeIds
		} else {
			content = {
				shapes: [],
				bindings: [],
				assets: [],
			}
		}

		return content
	}

	/**
	 * Get a screenshot (data URL) of the prompt's content
	 *
	 * @param content The content to get the image from
	 */
	private async getImage(content: TLAiContent) {
		// Get image from the content
		let image: string | undefined = undefined

		const svgResult = await this.editor.getSvgString(content.shapes, {
			background: false,
			darkMode: false,
			padding: 0, // will the context bounds take into account the padding?
		})

		if (svgResult) {
			const blob = await getSvgAsImage(this.editor, svgResult.svg, {
				type: 'jpeg',
				height: svgResult.height,
				width: svgResult.width,
			})
			if (blob) {
				image = await FileHelpers.blobToDataUrl(blob)
			}
		}

		return image
	}
}

function roundBox(box: Box) {
	const b = box.clone()
	b.x = Math.round(b.x)
	b.y = Math.round(b.y)
	b.width = Math.round(b.width)
	b.height = Math.round(b.height)
	return b
}
